# JPA_STUDY
JPA STUDY 정리


##### tip
> 새로운 maven 프로젝트를 만들어 jpa 실습을 진행할때 의존성과 persistence.xml을 설정한후 메이븐 파일을 reload해준다.
> 그래야 설정한 파일을 받아와서 오류가 안생긴다.






직렬화 : 개체를 파일로 저장
역직렬화 : 저장된 파일을 객체로 복구.

관계형 데이터 베이스
- 구성 : 테이블 (키- key + 값-value)
- 데이터의 종속성을 관계라고 표현



jpa 문법

- 저장 : persist()메소드
- 조회 : find() 메소드 


** 메이븐(maven) && 그래들(gradle)
- 메이븐 : 자바용 프로젝트 관리 도구
- 그래들: groovy를 이용한 빌드 자동화 시스템.



### JPQL 
jpql :엔티티 객체를 조회하는 객체지향 쿼리 언어.
        sql 과 비슷한 문법을 가진 객체 지향 쿼리. -> jpa에서 제공하는 메서드 호출만으로는 섬세한 쿼리 작성이 어렵다.
ex) find()메서드: 식별자를 통해서만 데이터 조회를 함(조건문x,모든 칼럼을 조회.)==>복잡한 검색을 수행할 수 없다. 즉, JPQL이 나오게된 배경.

특징)
1. 테이블이 아닌 객체를 검색하는 객체지향 쿼리
2. SQL을 추상화 한것 == 특정 벤더에 종속적이지 않다.
3. JPA는 JPQL을 분석하여 SQL을 생성한 후 DB에서 조회한다.
** JPQL은 데이터베이스 테이블을 전혀 알지 못한다.

기본 문법)
1. 대소문자 구분.
- 엔티티와 속성은 대소문자를 구분.
-but, JPQL은 대소문자를 구분하지 않는다.

2. 엔티티 이름 
- from 뒤에 나오는 이름 == 엔티티이름 : @Entity(name="")으로 설정한 엔티티이름 / name 속성을 생략하면 기본값으로 클래스이름을 사용.








### 3장. 영속성 관리

#### [3.1] 엔티티 매니저 팩토리와 엔티티 매니저
> 1) 엔티티 매니저 팩토리 
>	-  엔티티 매니저를 만드는 공장
>	- 여러 스레트가 동시에 접근 가능
>	- 여러 스레드간의 공유 가능
> 2) 엔티티 매니저
>	- 여러스레드 동시 접근시 동시성 문제 발생
>	- 스레드 간의 절대 공유 안된다.
>	- 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.


#### [3.2] 영속성 컨텍스트

> *** 영속성 컨텍스트 
>	- 엔티티를 영구 저장하는 환경.
>	- persist() 메소드는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장.        
	          

#### [3.3] 엔티티의 생명주기 
> - 비영속 : 영속성 컨텍스트와 전혀 관계가 없는상태
> - 영속 : 영속성 컨텍스트에 저장된 상태
> - 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
> - 삭제 : 삭제된 상태

> 1) 비영속
> - 엔티티 객체를 생성 했다.
> - 순수한 객체 상태 & 아직 저장 x
> - ex) Member member = new Member();
>        member.setId(id);
>        member.setUsername("user3");
>        member.setAge(20);

> 2) 영속 
> - 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태
> - 즉, 영속성 컨텍스트에 의해 관리된다는 뜻이다.
> - ex) em.persist(member);

> 3) 준영속 
> - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 관리하지 않으면 준영속 상태라고 한다.
> - em.detach()메소드 호출시 준영속 상태가 된다.
> - or em.close() or em.clear() 을 호출해 영속성 컨텍스트를 초기화해도 해당 컨텍스트가 관리하던 영속상태의 엔티티는 준영속 상태가 된다.

> 4) 삭제
> - 엔티티를 영속석 컨텍스트와 데이터베이스에서 삭제한다.
> - em.remove(member);


#### [3.4]영속성 컨텍스트의 특징
> - 영속성 컨텍스트와 식별자 값
>	->영속성 컨텍스트는 엔티티를 식별자 값으로 구분. == 영속상태는 식별자 값이 반드시 있어야한다.
> - 영속성 컨텍스트와 데이터베이스 저장 == 플러쉬
> - 영속성 컨텍스트가 엔티티를 관리하면 생기는 장점.

> ** 엔티티 등록
> - 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터 베이스에 엔티티를 저장하지않고 내부 쿼리 저장소에  insert sql을 차곡차곡모아둔다.
> - 트랜잭셕이 커밋할때 모아둔 쿼리를 데이터베이스에 보낸다.== 쓰기 지연. ==플러쉬



> ** 변경 감지
> - 엔티티의 변경사항을 데이터 베이스에 자동으로 반영하는 기능.
> - 영속성 컨텍스트가 관리하는 영속상태의 엔티티에만 적용된다.         




#### [3.5]플러시

> 1. 플러시 하는방법
> 1) em.flush()직접 호출
> 2) 트랜잭션 커밋 시 플러시가 자동으로 호출
> 3) jpql쿼리 실행시 자동 호출           



 



### 4장 엔티티 매핑

- JPA를 사용하는 데 가장 중요한 일은 엔티티와 테이블을 정확히 매핑하는 일.
*** 매핑 어노테이션은 매우 중요!
- 대표 어노테이션
1) 객체와 테이블 매핑 : @Entity, @Table
2) 기본키 매핑 : @Id
3) 필드와 컬럼 매핑 : @Column
4) 연관관계 매핑 : @ManyToOne , @JoinColumn             

#### [4.1] @Entity           
- @Entity가 붙은 클래스는 JPA가 관리하는 것
- JPA를 사용해서 테이블과 매핑할 클래스는 이 어노테이션을 필수로 붙여야 한다.
- JPA가 엔티티 객체를 생성할때, 기본 생성자를 사용하므로 기본생성자는 필수로 있어야 한다.
- 속성
	-> name : 엔티티 이름 지정. 설정하지않으면 클래스 이름을 그대로 사용한다.          

#### [4.2] @Table
- 엔티티와 매핑할 테이블을 지정한다. 생략하면 매핑한 엔티티이름을 테이블 이름으로 사용한다.            


 
#### [4.3] 다양한 매핑 사용.
- 실습 : Mapping Test 파일
- 추가된 요구 사항 
1. 회원은 일반회원과 관리자로 구분  => 자바의 enum을 사용해서 회원의 타입을 구분할 수 있다. -> enum을 사용하려면 @Enumerated 어노테이션으로 매핑해야한다.
2. 회원 가입일과 수정일이 있어야한다. => 자바의 날짜 타입은 @Temporal을 사용해서 매핑한다.
3. 회원을 설명할수 있는 필드가 있어야한다. 이 필드의 길이는 제한이 없다. => 길이제한이 없는 타입은 데이터 베이스에 VARCHAR이 아니라 CLOB타입으로 저장해야한다.-> @LOB 어노테이션 사용.

=> 스키마 자동생성 기능을 사용 
	- persistence.xml에속성을 추가
    <property name="hibernate.hbm2ddl.auto" value="create"/>


#### [4.6] 기본 키 매핑

- 직접 할당 : 기본기를 애플리케이션에서 직접 할당한다.
- 자동 생성 : 대리 키 사용 방식.
1) IDENTITY : 기본 키 생성을 데이터 베이스에 위임한다.
 	-> @GeneratedValue(strategy=GenerationType.IDENTITY)
2) SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
3) TABLE : 키 생성 테이블을 사용한다.

- IDENTITY 전략                             
	데이터 베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
	테이블에 데이터를 저장해야 식별자 값을 획득할 수 있다.

- TABLE 전략                  
	키 생성 전용 테이블을 하나 만들고, 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터 베이스 시퀀스를 흉내내는 전략.





### 5장 연관 관계 매핑 기초
- 엔티티들은 다른 엔티티들과 연관 관계를 가진다.                         
- **객체** : 참조 / 테이블 : 외래키 => 둘이 너무 다른 특징.                                     
	따라서 객체관계 매핑에서 가장 어려운 부분이 바로 객체 연관 관계와 테이블 연관관계를 매핑하는 일이다.                
*** 객체의 참조와 테이블의 외래 키를 매핑하는 것이 목표이다.

- **방향** : [단방향,양방향]이 있다. 방향은 객체에만 존재. 테이블 관계는 항상 양방향 관계이다.
- **다중성** : [N:1(다대일)],[1:N(일대다)],[1:1(일대일)],[N:N(다대다)] 다중성이 존재.
- **연관관계의 주인** : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.























